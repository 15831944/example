# 

`truss` 和 `strace` 用来跟踪一个进程的系统调用或信号产生的情况，而 `ltrace` 用来跟踪进程调用库函数的情况。
`truss` 是早期为 System V R4 开发的调试程序，包括 Aix、FreeBSD 在内的大部分 Unix 系统都自带了这个工具；
而 `strace` 最初是为SunOS系统编写的，`ltrace` 最早出现在GNU/DebianLinux中。

这两个工具现在也已被移植到了大部分Unix系统中，大多数Linux发行版都自带了strace和ltrace，而FreeBSD也可通过Ports安装它们。

你不仅可以从命令行调试一个新开始的程序，也可以把truss、strace或ltrace绑定到一个已有的PID上来调试一个正在运行的程序。
三个调试工具的基本使用方法大体相同，下面仅介绍三者共有，而且是最常用的三个命令行参数：

- -f ：除了跟踪当前进程外，还跟踪其子进程。
- -o file ：将输出信息写到文件file中，而不是显示到标准错误输出（stderr）。
- -p pid ：绑定到一个由pid对应的正在运行的进程。此参数常用来调试后台进程。

使用上述三个参数基本上就可以完成大多数调试任务了，下面举几个命令行例子：
`truss -o ls.truss ls -al`： 跟踪ls -al的运行，将输出信息写到文件/tmp/ls.truss中。
`strace -f -o vim.strace vim`： 跟踪vim及其子进程的运行，将输出信息写到文件vim.strace。
`ltrace -p 234`： 跟踪一个pid为234的已经在运行的进程。

三个调试工具的输出结果格式也很相似，以strace为例：

```text
brk(0) = 0×8062aa8
brk(0×8063000) = 0×8063000
mmap2(NULL, 4096, PROT_READ, MAP_PRIVATE, 3, 0×92f) = 0×40016000
```

每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。
`truss`、`strace` 和 `ltrace` 的工作原理大同小异，都是使用 `ptrace` 系统调用跟踪调试运行中的进程。

## 原理

### 調試進程的控制

1） 終止進程運行

在使用調試器調試程序時，被調試程序被中斷的條件有：

1. 調試器設置的斷點（指令斷點和數據斷點）滿足條件。
2. 進程收到一個信號（SIGKILL除外）。
3. 單步調用完成。
4. 系統調用調試下，進入或離開系統調用。

A. 斷點

設置斷點是調試器中的一個重要功能。80386 提供了兩種方式，INT3 和利用調試寄存器。
如果使用INT3方式設置斷點，則調試器通過 `ptrace` 的 PTRACE_POKETEXT 功能在斷點處插入INT3單字節指令。當進程運行到斷點時（INT3處），則系統進入異常 3 的處理。
若使用調試寄存器，則調試器通過調用`ptrace`(PTRACE_POKEUSR，pid，0，data) 在 DR0-DR3 寄存器設置與四個斷點條件的每一個相聯繫的線性地址在 DR7 中設置斷點條件。被跟蹤進程運行到斷點處時，CPU 產生異常 1，從而轉至函數do_debug處理。由於子進程在調試狀態下屬於正常調試異常，所以`do_debug`函數處理中產生SIGTRAP信號，為處理這個信號，進入 do_signal，使被調試進程停止，並通知調試器（父進程），此時得到子進程終止原因為SIGTRAP。

B. 信號

在有些情況之下，要求調試器調試某進程時，當進程收到某一信號的時候中斷進程運行。如：被調試進程在某處運算錯誤，進程會接收到SIGFPE信號，在正常運行狀況下，會Coredump，而調試的情況下則希望在產生錯誤代碼處停止運行，可以讓用戶調試錯誤原因。 對於已經被調試的進程（PF_PTRACED標誌置位），當受到任何信號（SIGKILL除外）會中止其運行，並通知調試器（父進程）。（詳見do_signal分析）

C. 單步執行

單步執行也是一種使進程中止的情況。當用戶調用ptrace的PTRACE_SINGLESTEP功能時，ptrace處理中，將用戶態標誌寄存器EFLAG中TF標誌為置位，並讓進程繼續運行（具體分析見ptrace函數分析）。當進程回到用戶態運行了一條指令後，CPU產生異常 1，從而轉至函數do_debug處理。由於子進程在調試狀態下屬於正常調試異常，所以do_debug函數處理中產生SIGTRAP信號，為處理這個信號，進入do_signal，使被調試進程停止，並通知調試器（父進程），此時得到子進程終止原因為SIGTRAP。

D. 系統調用調試

對程序的調試，有時希望對系統調用進程跟蹤。當程序進行系統調用時中斷其運行。ptrace提供PTRACE_SYSCALL功能完成此功能。在ptrace調用中設置了進程標誌PF_TRACESYS，表示進程對系統調用進行跟蹤，並繼續執行進程（具體分析見ptrace函數分析）。直到進程調用系統調用時，則中止其運行，並通知調試器（父進程）。（詳見syscall_trace分析）

2) 繼續進程執行

讓中斷的進程繼續執行，ptrace提供三種功能

1. 繼續執行（PTRACE_CONT）
2. 系統調用調試（PTRACE_SYSCALL）
3. 單步執行（PTRACE_SINGLESTEP）

三種功能的區別在於PTRACE_CONT功能讓進程繼續執行直到下一個斷點或收到一個信號會中止進程運行。PTRACE_SYSCALL功能讓進程繼續執行增加了一個中止條件，進程調用系統調用。PTRACE_SINGLESTEP功能讓進程繼續執行，只執行一個機器指令，則就中止其運行。 當被調試進程因為受到一個信號而中止時，這個信號並沒有被處理。如果希望繼續運行進程時繼續處理這個信號，則在上述三個ptrace功能調用時，最後一個參數data設置要繼續處理的信號。這種情況出現在，如：中止進程運行的信號為用戶自定義信號，用戶想繼續運行進程，而不要忽略用戶信號處理。有時，用戶希望忽略其信號處理，這時則參數data設置為0，這種情況出現在，如：由於算術錯誤接收到SIGFPE信號使進程中止，而用戶發現了錯誤，重新設置了正確的值，然後希望其繼續執行，這時SIGFPE信號則需要忽略。

根據ptrace的具體工作原理，我們知道控制被調試進程的關鍵在於兩點。第一、按照我們的需要產生異常使被調試程序停下來，無論是使用INT3還是調試寄存器。然後在異常處理函數中發出信號，這些信號可以被調試器接收。第二、使用內存映射的方法讀取被調試程序的數據空間，實現對被調試程序的信息監控。

還有一個值得注意的問題是信號處理函數執行的時機。信號函數會在執行流從內核空間返回用戶空間前夕判斷並執行。一個被調試程序執行完異常處理後，它必須返回用戶空間繼續執行。這可以保證信號處理一定會優先於用戶空間的代碼運行。在通常的情況下，這個信號處理函數會導致被調試程序停止，同時父進程（調試器）也會收到這一信號。
